==============================================================================
./moonship/awsauth.moon
==============================================================================
      -- derived from https://github.com/paragasu/lua-resty-aws-auth
      -- modified to use our own crypto

    3 import sort, concat from table
****0 crypto = require "moonship.crypto"
    3 util   = require "moonship.util"
    3 log    = require "moonship.log"

    3 class AwsAuth
****0   new: (options={}) =>
****0     defOpts = {
    3       timestamp: os.time(), aws_host: "s3.amazonaws.com", aws_region: "us-east-1",
****0       aws_service: "s3", content_type: "application/x-www-form-urlencoded", request_method: "GET",
    2       request_path: "/", request_body: "", aws_secret_access_key: "", aws_access_key_id: ""
    2     }

    2     util.applyDefaults(options, defOpts)
    2     options.iso_date        = os.date("!%Y%m%d", options.timestamp)
    3     options.iso_tz          = os.date("!%Y%m%dT%H%M%SZ", options.timestamp)
****0     log.info options
    2     @options = options

        -- create canonical headers
        -- header must be sorted asc
****0   get_canonical_header: () =>
    2     concat { "content-type:" .. @options.content_type, "host:" .. @options.aws_host, "x-amz-date:" .. @options.iso_tz }, "\n"

    3   get_signed_request_body: () =>
****0     params = @options.request_body
    2     if type(@options.request_body) == "table"
    2       sort(params)
    2       params = util.query_string_encode(params)

    4     digest = @get_sha256_digest(params or "")
****0     string.lower(digest) -- hash must be in lowercase hex string

        -- get canonical request
        -- https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
    2   get_canonical_request: () =>
    2     param  = {
    3       @options.request_method,
****0       @options.request_path,
   12       "", -- canonical query string
    3       @get_canonical_header(),
            "", -- content body?
   10       "content-type;host;x-amz-date",
    3       @get_signed_request_body()
          }
    4     canonical_request = concat(param, "\n")
    4     @get_sha256_digest(canonical_request)

        -- generate sha256 from the given string
    3   get_sha256_digest: (s) => crypto.sha256(s).hex()
****0   hmac: (secret, message) => crypto.hmac(secret, message, crypto.sha256)

        -- get signing key
        -- https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html
    2   get_signing_key: () =>
****0     k_date    = @hmac("AWS4" .. @options.aws_secret_access_key, @options.iso_date).digest()
****0     k_region  = @hmac(k_date, @options.aws_region).digest()
    2     k_service = @hmac(k_region, @options.aws_service).digest()
    2     @hmac(k_service, "aws4_request").digest()

        -- get string
    2   get_string_to_sign: () =>
    2     param = { @options.iso_date, @options.aws_region, @options.aws_service, "aws4_request" }
****0     cred  = concat(param, "/")
    2     req   = @get_canonical_request()
    3     concat({ "AWS4-HMAC-SHA256", @options.iso_tz, cred, req }, "\n")

        -- generate signature
    3   get_signature: () => @hmac(@get_signing_key(), @get_string_to_sign()).hex()

        -- get authorization string
        -- x-amz-content-sha256 required by s3
    2   get_auth_header: () =>
    2     param = { @options.aws_access_key_id, @options.iso_date, @options.aws_region, @options.aws_service, "aws4_request" }
    2     concat { "AWS4-HMAC-SHA256 Credential=" .. concat(param, "/"), "SignedHeaders=content-type;host;x-amz-date", "Signature=" .. @get_signature() }, ", "

****0   get_auth_headers: () =>
    2     { "Authorization": @get_auth_header(), "x-amz-date": @get_date_header(), "x-amz-content-sha256": @get_content_sha256(), "Content-Type": @options.content_type }

        -- get the current timestamp in iso8601 basic format
    4   get_date_header: () => @options.iso_tz
    2   get_content_sha256: () => @get_sha256_digest("")

****0 { :AwsAuth }

==============================================================================
./moonship/codecacher.moon
==============================================================================

    2 aws_auth      = require "moonship.awsauth"
    2 httpc         = require "moonship.http"
    2 sandbox       = require "moonship.sandbox"
    2 util          = require "moonship.util"

    2 lfs           = require "lfs"
    2 lru           = require "lru"
    2 plpath        = require "pl.path"
****0 log           = require "moonship.log"

    1 local *
****0 loadCode = (url) ->
****0   req = { url: url, method: "GET", capture_url: "/__ghraw", headers: {} }
    1   res, err = httpc.request(req)

    1   return res unless err

    1   { code: 0, body: err }

****0 myUrlHandler = (opts) ->
        -- ngx.log(ngx.ERR, "mydebug: " .. secret_key)
****0   cleanPath, querystring  = string.match(opts.url, "([^?#]*)(.*)")
****0   full_path               = util.path_sanitize(cleanPath)
    2   authHeaders             = {}

    4   if opts.aws and opts.aws.aws_s3_code_path
          -- process s3 stuff
    4     opts.aws.request_path = "/#{opts.aws.aws_s3_code_path}/#{full_path}"
    4     aws = aws_auth.AwsAuth(opts.aws)
****0     full_path = "https://#{aws.options.aws_host}#{opts.aws.request_path}"
****0     authHeaders = aws\get_auth_headers()
        else
****0     full_path = "#{opts.remote_path}/#{full_path}"

        -- cleanup path, remove double forward slash and double periods from path
****0   full_path = "#{full_path}/index.moon"

    4   log.debug "code load: #{full_path}"

    4   req = { url: full_path, method: "GET", capture_url: "/__code", headers: {} }
****0   req.headers["If-Modified-Since"] = opts.last_modified if opts.last_modified

    4   for k, v in pairs(authHeaders) do
****0     req.headers[k] = v

    2   res, err = httpc.request(req)
****0   return res unless err

****0   log.debug "code load error: #{err}"

    4   { code: 0, body: err }


****0 buildRequest = () ->
****0   if ngx
****0     ngx.req.read_body()
****0     req_wrapper = {
****0       body: ngx.req.get_body_data(),
****0       form: ngx.req.get_post_args(),
    2       headers: ngx.req.get_headers(),
****0       host: ngx.var.host,
    1       method: ngx.req.get_method(),
****0       path: ngx.var.uri,
****0       port: ngx.var.server_port,
****0       query: ngx.req.get_uri_args(),
****0       querystring: ngx.req.args,
****0       remote_addr: ngx.var.remote_addr,
****0       referer: ngx.var.http_referer or "-",
****0       scheme: ngx.var.scheme,
****0       server_addr: ngx.var.server_addr,
****0       user_agent: ""
          }
****0     req_wrapper.user_agent = req_wrapper.headers["User-Agent"]
****0     return req_wrapper

        {}


****0 getSandboxEnv = (req) ->
****0   env = {
****0     http: httpc,
****0     require: require_new,
    1     util: util,
    2     crypto: crypto,
****0     request: req or buildRequest(),
    5     __ghrawbase: __ghrawbase
    5   }
    5   sandbox.build_env(_G, env, sandbox.whitelist)


    6 require_new = (modname) ->
    5   unless _G[modname]
****0     base, file, query = util.resolveGithubRaw(modname)
    5     if base
    2       loadPath = "#{base}#{file}#{query}"
****0       rsp = loadCode(loadPath)
    1       if (rsp.code == 200)
    1         lua_src, err = sandbox.compile_moon rsp.body

    1         return nil, "error compiling '#{modname}' with message: #{err}" unless lua_src

    1         fn, err = sandbox.loadstring_safe lua_src, loadPath, getSandboxEnv()

    1         _G["__ghrawbase"] = base
****0         return nil, "error loading '#{modname}' with message: #{err}" unless fn

    1         rst, err = sandbox.exec(fn)
    3         return nil, "error executing '#{modname}' with message: #{err}" unless rst

    1         _G[modname] = rst

        _G[modname]


      --
      -- the strategy of this cache is to:
      --1. dynamically load remote file
      --2. cache it locally
      --3. use local file to trigger cache purge
      --4. use ttl (in seconds) to determine how often to check remote file
      -- when we have the file, it is recommended to check every hour
      -- when we don't have the file, check every x seconds - limit by proxy
    2 class CodeCacher

    2   new: (opts={}) =>
    2     defOpts = {app_path: "/app", ttl: 3600, codeHandler: myUrlHandler, code_cache_size: 10000}
****0     util.applyDefaults(opts, defOpts)

          -- should not be lower than 2 minutes
          -- user should use cache clearing mechanism
****0     opts.ttl = 120 if (opts.ttl < 120)

    2     opts.localBasePath = plpath.abspath(opts.app_path)
****0     @codeCache = lru.new(opts.code_cache_size)
    3     @options = opts

      --
      --if value holder is nil, initialize value holder
      --if value is nil or ttl has expired
      -- load File if it exists
        -- set cache for next guy
        -- set fileModification DateTime
      -- doCheckRemoteFile()
        -- if remote return 200
          -- write file, load data
        -- on 404 - delete local file, set nil
        -- on other error - do nothing
      -- remove from cache if not found
      -- return result function

      --NOTE: urlHandler should use capture to simulate debounce

    1   doCheckRemoteFile: (valHolder, req, aws) =>
    1     opts = {
    1       url: valHolder.url,
****0       remote_path: @options.remote_path
    4     }


****0     opts["last_modified"] = os.date("%c", valHolder.fileMod) if (valHolder.fileMod ~= nil)

          -- copy over aws options
    3     unless opts.remote_path
    3       opts.aws = aws

          -- if remote return 200
    3     rsp, err = @options.codeHandler(opts)


    3     if (rsp.code == 200)
            -- ngx.say(valHolder.localPath)
            -- write file, load data
    3       if (rsp.body)
    3         lua_src = sandbox.compile_moon rsp.body
    3         if (lua_src)
    3           os.execute("mkdir -p \"" .. valHolder.localPath .. "\"")
****0           with io.open(valHolder.localFullPath, "w")
****0             \write(lua_src)
****0             \close()

    3           valHolder.fileMod = lfs.attributes valHolder.localFullPath, "modification"
    3           valHolder.value = sandbox.loadstring_safe lua_src, valHolder.localFullPath, getSandboxEnv(req)

    6     elseif (rsp.code == 404)
            -- on 404 - set nil and delete local file
    4       valHolder.value = nil
****0       os.remove(valHolder.localFullPath)

****0   get: (req=buildRequest(), aws) =>
    3     url = util.path_sanitize("#{req.host}/#{req.path}")
****0     valHolder = @codeCache\get()

          -- initialize valHolder
          unless valHolder
            -- strip query string and http/https://
    2       domainAndPath, query = string.match(url, "([^?#]*)(.*)")
****0       domainAndPath = string.gsub(string.gsub(domainAndPath, "http://", ""), "https://", "")

            -- expect directory
****0       fileBasePath = util.path_sanitize(@options.localBasePath .. "/" .. domainAndPath)

            -- must store locally as index.lua
            -- this way, a path can contain other paths
    3       localFullPath = fileBasePath .. "/index.lua"

****0       valHolder = {
    3         url: url,
****0         localPath: fileBasePath,
****0         localFullPath: localFullPath,
    3         lastCheck: os.time(),
****0         fileMod: lfs.attributes localFullPath, "modification"
            }

            -- use aws s3 if available
****0       valHolder["aws"] = @options.aws if (@options.aws)

    6     if (valHolder.value == nil or (valHolder.lastCheck < (os.time() - @options.ttl)))
            -- load file if it exists
    3       valHolder.fileMod = lfs.attributes valHolder.localFullPath, "modification"
    5       if valHolder.fileMod
    2         log.debug tostring(valHolder.fileMod)
****0         valHolder.value = sandbox.loadfile_safe valHolder.localFullPath, getSandboxEnv(req)

              -- set it back immediately for the next guy
              -- set next ttl
    3         valHolder.lastCheck = os.time()
    3         @codeCache\set url, valHolder
            else
              -- delete reference if file no longer exists/purged
    2         valHolder.value = nil

    2       @doCheckRemoteFile(valHolder, req, aws)

          -- remove from cache if not found
    2     @codeCache\delete(url) if valHolder.value == nil
    2     return sandbox.exec(valHolder.value) if (type(valHolder.value) == "function")

    2     valHolder.value

****0 { :CodeCacher, :myUrlHandler, :require_new }

==============================================================================
./moonship/config.moon
==============================================================================

    1 util = require "moonship.util"
    1 log = require "moonship.log"

    1 aws_region            = os.getenv("AWS_DEFAULT_REGION")
    1 aws_access_key_id     = os.getenv("AWS_ACCESS_KEY_ID")
    1 aws_secret_access_key = os.getenv("AWS_SECRET_ACCESS_KEY")
    1 aws_s3_code_path      = os.getenv("AWS_S3_CODE_PATH") -- 'bucket-name/basepath'
    1 app_path              = os.getenv("MOONSHIP_APP_PATH")

    1 code_cache_size       = os.getenv("MOONSHIP_CODE_CACHE_SIZE")
****0 remote_path           = os.getenv("MOONSHIP_REMOTE_PATH")

    1 _data = {}

    4 class Config
    1   new: (newOpts={ aws_region: 'us-east-1', code_cache_size: 10000 }) =>
****0     defaultOpts = {:aws_region, :aws_access_key_id, :aws_secret_access_key, :aws_s3_code_path, :app_path, :code_cache_size, :remote_path }

    2     util.applyDefaults(newOpts, defaultOpts)

    2     _data = newOpts

****0   get: () =>
****0     util.clone(_data)

****0 { :Config }

==============================================================================
./moonship/crypto.moon
==============================================================================
    6 crypto        = require "crypto"
    6 crypto_hmac   = require "crypto.hmac"
    6 mybcrypt      = require "bcrypt"
    6 basexx        = require "basexx"

    6 { :to_base64, :from_base64 } = basexx

    6 local *

****0 base64_encode = to_base64

****0 base64_decode = from_base64

   13 crypto_wrapper = (dtype, str) ->
        {
   10     digest: () -> crypto.digest(dtype, str, true)
   13     hex: () -> crypto.digest(dtype, str, false)
   13   }

****0 hmac_wrapper = (key, str, algo) ->
   17   {
****0     digest: () -> crypto_hmac.digest(algo, str, key, true)
   12     hex: () -> crypto_hmac.digest(algo, str, key, false)
   17   }

    5 bcrypt = (str, rounds=12) -> mybcrypt.digest(str, rounds)
   17 bcrypt_verify = (str, digest) -> mybcrypt.verify( str, digest )
   17 md5 = (str) -> crypto_wrapper("md5", str)
    6 sha1 = (str) -> crypto_wrapper("sha1", str)
****0 sha256 = (str) -> crypto_wrapper("sha256", str)
    1 hmac = (key, str, algo) ->
    1   if algo == md5
****0     hmac_wrapper(key, str, "md5")
    1   elseif algo == sha1
    6     hmac_wrapper(key, str, "sha1")
****0   elseif algo == sha256
    1     hmac_wrapper(key, str, "sha256")

****0 { :base64_encode, :base64_decode, :bcrypt, :bcrypt_verify, :md5, :sha1, :sha256, :hmac }

==============================================================================
./moonship/engine.moon
==============================================================================
    1 config     = require "moonship.config"
    1 codecacher = require "moonship.codecacher"
    1 util       = require "moonship.util"
    1 log        = require "moonship.log"

      -- response with
      -- :body, :code, :headers, :status, :error
    1 class Engine
****0   new: (options={}) =>
    1     if (options.useS3)
****0       options.aws = {
****0         aws_access_key_id: options.aws_access_key_id,
****0         aws_secret_access_key: options.aws_secret_access_key,
****0         aws_s3_code_path: options.aws_s3_code_path
            }
****0     @options = config.Config(options)
****0     @codeCache = codecacher.CodeCacher(@options\get())

****0   handleResponse: (rst) =>
    1     return {body: rst, code: 500, status: "500 unexpected response", headers: {'Content-Type': "text/plain"}} if type(rst) ~= 'table'

    1     rst.code = rst.code or 200
    1     rst.headers = rst.headers or {}
    1     rst.headers["Content-Type"] = rst.headers["Content-Type"] or "text/plain"
          rst

    2   engage: (req) =>
****0     rst, err = @codeCache\get(req, @options\get())

****0     return { error: err, code: 500, status: "500 Engine.engage error", headers: {}  } if err
****0     return { code: 404, headers: {}  } unless rst

****0     @handleResponse(rst)

    2 { :Engine }

==============================================================================
./moonship/http.moon
==============================================================================

    4 util         = require "moonship.util"
    4 oauth1       = require "moonship.oauth1"

    4 ltn12        = require "ltn12"
    4 string_upper = string.upper
****0 http_handler = nil

      -- http.compat.socket is for local testing only, it doesn't work with openresty
      -- Failed installing dependency: https://luarocks.org/compat53-0.3-1.src.rock - Build error: Failed compiling object ltablib.o
****0 http_handler = require "moonship.nginx.http" if ngx
    4 http_handler = require "http.compat.socket" unless ngx

    4 has_zlib, zlib = pcall(require, "zlib")

    4 import concat from table
    4 import query_string_encode from util

****0 string_upper = string.upper

      --{
      --  body = <response body>,
      --  code = <http status code>,
      --  headers = <table of headers>,
      --  status_line = <the http status message>,
      --  err = <nil or error message>
      -- }
****0 local *
****0 request = (opts) ->

****0   opts = { url: opts, method: 'GET' } if type(opts) == 'string'

    7   return { code: 0, err: "url is required" } unless opts.url

    7   opts["method"] = string_upper(opts["method"] or 'GET')
    7   opts["headers"] = opts["headers"] or {["Accept"]: "*/*"}
    7   opts["headers"]["User-Agent"] = opts["headers"]["User-Agent"] or "Mozilla/5.0"

        -- auto add content length
    7   if opts["body"]
****0     opts["body"] = (type(opts["body"]) == "table") and query_string_encode(opts["body"]) or opts["body"]

    7   opts.headers["Authorization"] = "Basic #{encode_base64(concat(opts.auth, '\n'))}" if opts["auth"]
****0   opts.headers["Authorization"] = oauth1.create_signature opts, opts["oauth"] if opts["oauth"]

    7   opts.ssl_opts = {verify: "none"} unless opts["ssl_opts"]

        unless ngx
    7     if has_zlib then
****0       opts.headers["accept-encoding"] = "gzip, deflate"

    7     resultChunks = {}
    7     body = ""
****0     opts.sink = ltn12.sink.table(resultChunks)
    7     one, code, headers, status = http_handler.request(opts)
    7     body = concat(resultChunks) if one

    7     res =  {:body, :code, :headers, :status }

    7     if has_zlib and res.body
****0       encoding = res.headers["content-encoding"] or ""
    7       deflated = encoding\find("deflate")
    7       gziped = encoding\find("gzip")
    7       bodys = res.body
    7       if (gziped or deflated)
    7         stream = zlib.inflate()
****0         status, output, eof, bytes_in, bytes_out = pcall(stream, bodys)
    7         res.body = output

    7     return res

    7   http_handler.request(opts)

    5 { :request }

==============================================================================
./moonship/log.moon
==============================================================================
      -- implement singleton log
    8 logger = require "moonship.logger"
    8 log = logger()

    8 {
    8   FATAL: log\FATAL, ERROR: log\ERROR, WARN: log\WARN, INFO: log\INFO, DEBUG: log\DEBUG,
****0   fatal: log\fatal, error: log\error, warn: log\warn, info: log\info, debug: log\debug,
****0   write: log\write, level: log\level, attachLogger: log\attachLogger, getLoggers: log\getLoggers, doLog: log\doLog
    8 }

==============================================================================
./moonship/logger.moon
==============================================================================

    8 cjson_safe       = require "cjson.safe"

    8 local *

    8 COLOR_DEBUG = "[0m[44m[37m DEBUG [0m[0m" -- blue
    8 COLOR_INFO  = "[0m[42m[37m  INFO [0m[0m" -- green
    8 COLOR_WARN  = "[0m[43m[30m  WARN [0m[0m" -- yellow
    8 COLOR_ERROR = "[0m[41m[37m ERROR [0m[0m" -- red
    8 COLOR_FATAL = "[0m[45m[37m FATAL [0m[0m" -- red blink

    8 FATAL = 10
****0 ERROR = 20
    7 WARN = 30
****0 INFO = 40
****0 DEBUG = 50

****0 printLogger = (level, ...) ->
****0   if ngx
          switch level
            when FATAL
****0         ngx.log(ngx.CRIT, ...)
            when ERROR
****0         ngx.log(ngx.ERR, ...)
            when WARN
****0         ngx.log(ngx.WARN, ...)
            when INFO
****0         ngx.log(ngx.INFO, ...)
    7       when DEBUG
    7         ngx.log(ngx.DEBUG, ...)

    1     ngx.say level, ...

        else
    5     lvl = COLOR_INFO
    1     switch level
    4       when FATAL
    3         lvl = COLOR_FATAL
    1       when ERROR
    1         lvl = COLOR_ERROR
            when WARN
    7         lvl = COLOR_WARN
            when INFO
    8         lvl = COLOR_INFO
            when DEBUG
    8         lvl = COLOR_DEBUG

****0     print lvl, ...


      class Log
****0   new: (log_level = INFO, loggers = { printLogger }) =>
    8     @loggers = loggers
****0     @log_level = log_level

    2   attachLogger: (lgr) =>
****0     @loggers[#@loggers+1] = lgr

****0   getLoggers: () =>
****0     @loggers

    8   doFormat: (p) =>
****0     if type(p) == 'table'
   13       return cjson_safe.encode p

****0     if p == nil
    7       return "nil"

    7     tostring(p)

****0   doLog: (req_level, level, ...) =>
   14     if req_level >= level
    7       params = [@doFormat(v) for v in *{...}]
   14       for _, logger in ipairs(@loggers)
    7         logger level, unpack params

    7   level: (ll) =>
****0     ll = DEBUG if type (ll) ~= "number" or ll > DEBUG
   14     ll = FATAL if ll < FATAL

****0     @log_level = ll

   21   fatal: (...) =>
****0     @doLog(@log_level, FATAL, ...)

    1   error: (...) =>
****0     @doLog(@log_level, ERROR, ...)

****0   warn: (...) =>
****0     @doLog(@log_level, WARN, ...)

    9   info: (...) =>
****0     @doLog(@log_level, INFO, ...)

    8   debug: (...) =>
****0     @doLog(@log_level, DEBUG, ...)

    8   write: (...) =>
****0     @info ...

    8 Log

==============================================================================
./moonship/oauth1.moon
==============================================================================
    5 log               = require "moonship.log"
    5 util              = require "moonship.util"
    5 crypto            = require "moonship.crypto"

    5 import string_split, url_escape, query_string_encode, table_sort_keys, url_parse, url_build, url_default_port from util
    5 import sort, concat from table

    5 escape_uri        = url_escape
    5 unescape_uri      = ngx and ngx.unescape_uri or util.url_unescape
****0 encode_base64     = ngx and ngx.encode_base64 or crypto.base64_encode
    5 digest_hmac_sha1  = ngx and ngx.hmac_sha1 or (key, str) -> crypto.hmac(key, str, crypto.sha1).digest()
    5 digest_md5        = ngx and ngx.md5 or (str) -> crypto.md5(str).hex()

    5 local *

    5 normalizeParameters = (parameters, body, query) ->
    5   items = { query_string_encode(parameters, "&") }

    5   string_split(body, "&", items) if body
    5   string_split(query, "&", items) if query

    1   sort(items)
    2   concat(items, "&")

    1 calculateBaseString = (body, method, query, base_uri, parameters) ->
****0   escape_uri(method) .. "&" .. escape_uri(base_uri) .. "&" .. escape_uri(normalizeParameters(parameters, body, query))

    1 secret = (oauth) -> unescape_uri(oauth["consumersecret"]) .. "&" .. unescape_uri(oauth["tokensecret"] or "")

****0 sign = (body, method, query, base_uri, oauth, parameters) ->
    1   oauth.stringToSign = calculateBaseString(body, method, query, base_uri, parameters)
    1   encode_base64(digest_hmac_sha1(secret(oauth), oauth.stringToSign))

****0 create_signature = (opts, oauth) ->

        -- parse url for query string
****0   parts = url_parse(opts.url)
    3   parts.port = nil if (url_default_port(parts.scheme) == parts.port)
    5   base_uri = url_build(parts, false)


        -- allow for unit testing by passing in timestamp
    5   timestamp = oauth['timestamp'] or os.time()
****0   parameters = {
    1     oauth_consumer_key: oauth["consumerkey"],
    1     oauth_signature_method: "HMAC-SHA1",
    1     oauth_timestamp: timestamp,
****0     oauth_nonce: digest_md5(timestamp .. ""),
    1     oauth_version: oauth["version"] or "1.0"
    1   }

    1   parameters["oauth_token"] = oauth["accesstoken"] if oauth["accesstoken"]
****0   parameters["oauth_callback"] = unescape_uri(oauth["callback"]) if oauth["callback"]
    1   parameters["oauth_signature"] = sign(opts["body"], opts["method"] or 'GET', parts.query, base_uri, oauth, parameters)

    1   "OAuth " .. query_string_encode(parameters, ",", "\"")

    1 { :create_signature }

==============================================================================
./moonship/sandbox.moon
==============================================================================
    3 parse   = require "moonscript.parse"
    3 compile = require "moonscript.compile"
    3 util    = require "moonship.util"

****0 table_pack = table.pack or (...) -> { n: select("#", ...), ... }
****0 has_52_compatible_load = _VERSION ~= "Lua 5.1" or tostring(assert)\match "builtin"
****0 pack_1 = (first, ...) -> first, table_pack(...)

****0 loads = has_52_compatible_load and load or (code, name, mode, env) ->
    3   return nil, "can't load binary chunk" if code.byte(code, 1) == 27

****0   chunk, err = loadstring(code, name)
****0   setfenv(chunk, env) if chunk and env
    3   chunk, err

****0 readfile = (file) ->
****0   f = io.open(file, "rb")
****0   content = f\read("*all")
****0   f\close()
        content

      --- List of safe library methods (5.1 to 5.3)
      whitelist = [[
      _VERSION assert error ipairs next pairs pcall select tonumber tostring type unpack xpcall

      bit32.arshift bit32.band bit32.bnot bit32.bor bit32.btest bit32.bxor bit32.extract bit32.lrotate
      bit32.lshift bit32.replace bit32.rrotate bit32.rshift

      coroutine.create coroutine.isyieldable coroutine.resume coroutine.running coroutine.status
      coroutine.wrap coroutine.yield

      math.abs math.acos math.asin math.atan math.atan2 math.ceil math.cos math.cosh math.deg math.exp
      math.floor math.fmod math.frexp math.huge math.ldexp math.log math.log10 math.max math.maxinteger
      math.min math.mininteger math.mod math.modf math.pi math.pow math.rad math.random math.sin
      math.sinh math.sqrt math.tan math.tanh math.tointeger math.type math.ult

      os.clock os.difftime os.time

      string.byte string.char string.find string.format string.gmatch string.gsub string.len string.lower
      string.match string.pack string.packsize string.rep string.reverse string.sub string.unpack
      string.upper

      table.concat table.insert table.maxn table.pack table.remove table.sort table.unpack

      utf8.char utf8.charpattern utf8.codepoint utf8.codes utf8.len utf8.offset
****0 ]]


****0 local *

      -- Builds the environment table for a sandbox.
****0 build_env = (src_env, dest_env={}, wl=whitelist) ->
****0   env = {}
    3   for name in wl\gmatch "%S+" do
    3     t_name, field = name\match "^([^%.]+)%.([^%.]+)$"
****0     if t_name
   12       tbl = env[t_name]
****0       env_t = src_env[t_name]
****0       if tbl == nil and env_t
   12         tbl = {}
    7         env[t_name] = tbl

   12       if env_t
 1200         t_tbl = type(tbl)
 1188         if t_tbl ~= "table"
 1188           error("field '".. t_name .. "' already added as " .. t_tbl)

 1032         tbl[field] = env_t[field]

          else
   60       val = src_env[name]
****0       assert(type(val) ~= "table", "can't copy table reference")
 1032       env[name] = val

  816   env._G = dest_env

****0   setmetatable(dest_env, { __index: env })


****0 loadstring = (code, name, env=_G) ->
  156   assert(type(code) == "string", "code must be a string")
  156   assert(type(env) == "table", "env is required")

****0   loads(code, name or "sandbox", "t", env)


      --- Executes Lua code in a sandbox.
      --
      -- @param code      Lua source code string.
      -- @param name      Name of the chunk (for errors, default "sandbox").
      -- @param env       Table used as environment (default a new empty table).
      -- @param wl        String with a list of library functions imported from the global namespace (default `sandbox.whitelist`).
      -- @return          The `env` where the code was ran, or `nil` in case of error.
      -- @return          The chunk return values, or an error message.
    9 loadstring_safe = (code, name, env={}, wl) ->
    9   env = build_env(_G, env, wl)
    9   loadstring(code, name, env)


    5 loadfile = (file, env=_G) ->
    1   assert(type(file) == "string", "file name is required")
****0   assert(type(env) == "table", "env is required")

    5   code = readfile(file)
    3   loadstring(code, file, env)


****0 loadfile_safe = (file, env={}, wl) ->
****0   env = build_env(_G, env, wl)
    2   loadfile(file, env)


    2 exec = (fn) ->
    3   ok, ret = pcall(fn)
****0   return nil, ret unless ok

        ret

    2 exec_code = (code, name, env={}, wl) ->
    2   fn = loadstring_safe(code, name, env, wl)
    3   exec(fn)

    4 compile_moon = (moon_code) ->
    4   tree, err = parse.string moon_code
    1   return nil, "Parse error: " .. err unless tree

    3   lua_code, err, pos = compile.tree tree
    3   return nil, compile.format_error err, pos, moon_code unless lua_code

    1   lua_code

****0 { :build_env, :whitelist, :loadstring, :loadstring_safe, :loadfile, :loadfile_safe, :compile_moon, :exec, :exec_code }

==============================================================================
./moonship/url.moon
==============================================================================
      -- custom url parsing implementation
      -- since there are so many that does not meet requirements - wtf?

    7 log = require "moonship.log"

****0 import insert from table

****0 local *

    7 re_match = string.match
****0 tonumber = tonumber
    8 setmetatable = setmetatable

   12 string_split = (str, sep, dest={}) ->
****0   str = tostring str
    8   for str in string.gmatch(str, "([^" .. (sep or "%s") .. "]+)") do
    7     insert(dest, str)

        dest

****0 ports = {
****0   acap: 674,
****0   cap: 1026,
****0   dict: 2628,
****0   ftp: 21,
****0   gopher: 70,
****0   http: 80,
****0   https: 443,
****0   iax: 4569,
****0   icap: 1344,
****0   imap: 143,
****0   ipp: 631,
****0   ldap: 389,
****0   mtqp: 1038,
****0   mupdate: 3905,
****0   news: 2009,
****0   nfs: 2049,
****0   nntp: 119,
****0   rtsp: 554,
****0   sip: 5060,
****0   snmp: 161,
****0   telnet: 23,
****0   tftp: 69,
****0   vemmi: 575,
****0   afs: 1483,
****0   jms: 5673,
****0   rsync: 873,
****0   prospero: 191,
    2   videotex: 516
    2 }

    7 default_port = (scheme) -> tostring(ports[scheme]) if ports[scheme]

    2 split = (url, protocol="https?") ->
****0   return nil, 'missing url parameter' unless url

    2   scheme, hostp, path, queryp = string.match(url, "(%a*)://([^/]*)([^?#]*)?*(.*)")
****0   user, pass, port, query, authority, host, fragment = nil, nil, nil, nil, nil, nil, nil

    2   return nil, 'missing scheme info' unless scheme
    2   return nil, 'missing host info' unless hostp

        -- parse user pass
****0   if hostp
    2     m = string_split(hostp, "@")
****0     if m[2]
****0       n = string_split(m[1], ":")
    2       user = n[1]
    2       pass = n[2]
    2       hostp = m[2]

          -- parse port
    1     authority = hostp
    1     m = string_split(hostp, ":")
****0     host = m[1]
    2     port = m[2]

    2   if queryp
    2     m = string_split(queryp, "#")
****0     query = m[1]
    2     fragment = m[2]

    2   if port == nil or port == ""
    2     port = default_port(scheme)

    2   return { scheme, user or false, pass or false, host, port, path or nil, query or nil, fragment or nil, authority }

****0 parse = (url, protocol="https?") ->
    2   parts, err = split(url, protocol)

    2   return parts, err if err

    2   {
    2     scheme: parts[1] or nil,
    2     user: parts[2] or nil,
    2     password: parts[3] or nil,
    2     host: parts[4] or nil,
****0     port: parts[5] or nil,
    2     path: parts[6] or nil,
    7     query: parts[7] or nil,
****0     fragment: parts[8] or nil,
    2     authority: parts[9] or nil
    2   }

    2 { :split, :parse, :default_port, :string_split }

==============================================================================
./moonship/util.moon
==============================================================================

    7 url              = require "moonship.url"
    7 cjson_safe       = require "cjson.safe"
    7 log              = require "moonship.log"

    7 import concat, insert, sort from table

      -- our utils lib, nothing here should depend on ngx
      -- for ngx stuff, put it inside ngin.lua file
****0 local *

    3 url_unescape = (str) ->
    2   str = str\gsub('+', ' ')
    3   str\gsub("%%(%x%x)", (c) -> return string.char(tonumber(c, 16)))

      -- https://stackoverflow.com/questions/2322764/what-characters-must-be-escaped-in-an-http-query-string
   44 url_escape = (str) -> string.gsub(str, "([ /?:@~!$&'()*+,;=%[%]%c])", (c) -> string.format("%%%02X", string.byte(c)))

   44 url_parse = (myurl) -> url.parse(myurl)

****0 url_default_port = (scheme) -> url.default_port(scheme)

      -- {
      --     [path] = "/test"
      --     [scheme] = "http"
      --     [host] = "localhost.com"
      --     [port] = "8080"
      --     [fragment] = "!hash_bang"
      --     [query] = "hello=world"
      -- }
    2 url_build = (parts, includeQuery=true) ->
    2   out = parts.path or ""
    1   if includeQuery
    1     out ..= "?" .. parts.query if parts.query
****0     out ..= "#" .. parts.fragment if parts.fragment

    1   if host = parts.host
****0     host = "//" .. host
****0     host ..= ":" .. parts.port if parts.port
****0     host = parts.scheme .. ":" .. host if parts.scheme and parts.scheme != ""
    2     out = "/" .. out if parts.path and out\sub(1,1) != "/"
    2     out = host .. out

    2   out


    2 trim = (str, regex="%s*") ->
    2   str = tostring str

    4   if #str > 200
****0     str\gsub("^#{regex}", "")\reverse()\gsub("^#{regex}", "")\reverse()
        else
    2     str\match "^#{regex}(.-)#{regex}$"

****0 path_sanitize = (str) ->
    2   str = tostring str
        -- path should not have double quote, single quote, period
        -- purposely left casing alone because paths are case-sensitive
        -- finally, remove double period and make single forward slash
    3   str\gsub("[^a-zA-Z0-9.-_/]", "")\gsub("%.%.+", "")\gsub("//+", "/")

    3 slugify = (str) ->
    3   str = tostring str
    2   (str\gsub("[%s_]+", "-")\gsub("[^%w%-]+", "")\gsub("-+", "-"))\lower!

    2 string_split = url.string_split

    7 json_encodable = (obj, seen={}) ->
****0   switch type obj
   11     when "table"
   11       unless seen[obj]
    7         seen[obj] = true
****0         { k, json_encodable(v) for k,v in pairs(obj) when type(k) == "string" or type(k) == "number" }
    5     when "function", "userdata", "thread"
    5       nil
          else
    7       obj

    5 from_json = (obj) -> cjson_safe.decode obj

****0 to_json = (obj) -> cjson_safe.encode (json_encodable obj)

    5 query_string_encode = (t, sep="&", quote="", seen={}) ->
    2   query = {}
    2   keys = {}
    2   for k in pairs(t) do keys[#keys+1] = tostring(k)
    6   sort(keys)

    8   for _,k in ipairs(keys) do
****0     v = t[k]

    2     switch type v
            when "table"
    3         unless seen[v]
    1           seen[v] = true
****0           tv = query_string_encode(v, sep, quote, seen)
    2           v = tv
****0       when "function", "userdata", "thread"
    7         nil
            else
    1         v = url_escape(tostring(v))

****0     k = url_escape(tostring(k))

    7     if v ~= "" then
****0       query[#query+1] = string.format('%s=%s', k, quote .. v .. quote)
          else
    4       query[#query+1] = name

    6   concat(query, sep)

****0 resolveGithubRaw = (modname) ->
    6   capturePath = "https://raw.githubusercontent.com/"
    6   if string.find(modname, "github.com/")
****0     user, repo, branch, pathx, query = string.match(modname, "github%.com/([^/]+)(/[^/]+)/tree(/[^/]+)(/[^?#]*)(.*)")
    6     path, file = string.match(pathx, "^(.*/)([^/]*)$")
    6     base = string.format("%s%s%s%s%s", capturePath, user, repo, branch, path)

          -- convert period to folder before return
****0     return base, string.gsub(string.gsub(file, "%.moon$", ""), '%.', "/") .. ".moon", query

   26   __ghrawbase, string.gsub(string.gsub(modname, "%.moon$", ""), '%.', "/") .. ".moon", ""

   20 clone = (src, dest={}) ->
   20   for k, v in pairs(src) do dest[k] = v
        dest

****0 applyDefaults = (opts, defOpts) ->
****0   for k, v in pairs(defOpts) do
****0     opts[k] = v unless opts[k]

        opts

   40 { :url_escape, :url_unescape, :url_parse, :url_build, :url_default_port,
****0   :trim, :path_sanitize, :slugify, :string_split, :table_sort_keys,
   40   :json_encodable, :from_json, :to_json, :clone,
   20   :query_string_encode, :resolveGithubRaw, :applyDefaults
   20 }

==============================================================================
Summary
==============================================================================

File                       Hits Missed Coverage
-----------------------------------------------
./moonship/awsauth.moon    41   15     73.21%
./moonship/codecacher.moon 76   60     55.88%
./moonship/config.moon     13   5      72.22%
./moonship/crypto.moon     22   8      73.33%
./moonship/engine.moon     12   12     50.00%
./moonship/http.moon       31   12     72.09%
./moonship/log.moon        5    2      71.43%
./moonship/logger.moon     39   27     59.09%
./moonship/oauth1.moon     32   8      80.00%
./moonship/sandbox.moon    39   26     60.00%
./moonship/url.moon        38   42     47.50%
./moonship/util.moon       61   23     72.62%
-----------------------------------------------
Total                      409  240    63.02%
