==============================================================================
./moonship/awsauth.moon
==============================================================================
      -- derived from https://github.com/paragasu/lua-resty-aws-auth
      -- modified to use our own crypto

    4 import sort, concat from table
****0 crypto = require "moonship.crypto"
    4 util   = require "moonship.util"
    4 log    = require "moonship.log"

    4 class AwsAuth
****0   new: (options={}) =>
****0     defOpts = {
    4       timestamp: os.time(), aws_host: "s3.amazonaws.com", aws_region: "us-east-1",
****0       aws_service: "s3", content_type: "application/x-www-form-urlencoded", request_method: "GET",
    2       request_path: "/", request_body: "", aws_secret_access_key: "", aws_access_key_id: ""
    2     }

    2     util.applyDefaults(options, defOpts)
    2     options.iso_date        = os.date("!%Y%m%d", options.timestamp)
    4     options.iso_tz          = os.date("!%Y%m%dT%H%M%SZ", options.timestamp)
****0     @options = options

        -- create canonical headers
        -- header must be sorted asc
****0   get_canonical_header: () =>
****0     concat { "content-type:" .. @options.content_type, "host:" .. @options.aws_host, "x-amz-date:" .. @options.iso_tz }, "\n"

    2   get_signed_request_body: () =>
    4     params = @options.request_body
****0     if type(@options.request_body) == "table"
    2       sort(params)
    2       params = util.query_string_encode(params)

****0     digest = @get_sha256_digest(params or "")
    4     string.lower(digest) -- hash must be in lowercase hex string

        -- get canonical request
        -- https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
****0   get_canonical_request: () =>
    2     param  = {
    2       @options.request_method,
    4       @options.request_path,
            "", -- canonical query string
   12       @get_canonical_header(),
    4       "", -- content body?
            "content-type;host;x-amz-date",
   10       @get_signed_request_body()
    4     }
****0     canonical_request = concat(param, "\n")
    4     @get_sha256_digest(canonical_request)

        -- generate sha256 from the given string
    4   get_sha256_digest: (s) => crypto.sha256(s).hex()
    4   hmac: (secret, message) => crypto.hmac(secret, message, crypto.sha256)

        -- get signing key
        -- https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html
    2   get_signing_key: () =>
    2     k_date    = @hmac("AWS4" .. @options.aws_secret_access_key, @options.iso_date).digest()
****0     k_region  = @hmac(k_date, @options.aws_region).digest()
****0     k_service = @hmac(k_region, @options.aws_service).digest()
    2     @hmac(k_service, "aws4_request").digest()

        -- get string
****0   get_string_to_sign: () =>
    2     param = { @options.iso_date, @options.aws_region, @options.aws_service, "aws4_request" }
    2     cred  = concat(param, "/")
****0     req   = @get_canonical_request()
    2     concat({ "AWS4-HMAC-SHA256", @options.iso_tz, cred, req }, "\n")

        -- generate signature
    8   get_signature: () => @hmac(@get_signing_key(), @get_string_to_sign()).hex()

        -- get authorization string
        -- x-amz-content-sha256 required by s3
    2   get_auth_header: () =>
    2     param = { @options.aws_access_key_id, @options.iso_date, @options.aws_region, @options.aws_service, "aws4_request" }
    2     concat { "AWS4-HMAC-SHA256 Credential=" .. concat(param, "/"), "SignedHeaders=content-type;host;x-amz-date", "Signature=" .. @get_signature() }, ", "

****0   get_auth_headers: () =>
****0     { "Authorization": @get_auth_header(), "x-amz-date": @get_date_header(), "x-amz-content-sha256": @get_content_sha256(), "Content-Type": @options.content_type }

        -- get the current timestamp in iso8601 basic format
****0   get_date_header: () => @options.iso_tz
    4   get_content_sha256: () => @get_sha256_digest("")

    4 AwsAuth

==============================================================================
./moonship/azauth.moon
==============================================================================
    3 hmacauth         = require "moonship.hmacauth"
    3 crypto           = require "moonship.crypto"
    3 util             = require "moonship.util"
    3 log              = require "moonship.log"

    3 import url_parse, string_split, query_string_encode from util
    3 import concat, sort from table
****0 import base64_decode, base64_encode from crypto

    3 local *

    3 date_utc = (date=os.time()) -> os.date("!%a, %d %b %Y %H:%M:%S GMT", date)

    3 getHeader = (headers, name, additionalHeaders={}) -> headers[name] or additionalHeaders[name] or ""

    3 sharedkeylite = (opts = { :account_name, :account_key, :table_name }) ->
****0   opts.time = opts.time or os.time()
****0   opts.date = opts.date or date_utc(opts.time)
    3   opts.sig = hmacauth.sign(base64_decode(opts.account_key), "#{opts.date}\n/#{opts.account_name}/#{opts.table_name}")
    3   opts

****0 canonicalizedResource = (opts) ->
****0   parsedUrl = opts.parsedUrl
****0   query = string_split(opts.query, "&")
****0   qs = query_string_encode(query, "\n", "", (v) -> v)

****0   params = {
    3     "/#{opts.account_name}#{parsedUrl.path}",
          qs
        }

****0   concat(params, "\n")

****0 canonicalizedHeaders = (headers) ->
    3   rst = {}
    6   keys = {}

        -- sort
    3   for k in pairs(headers) do keys[#keys+1] = tostring(k)
****0   sort(keys)

****0   for _, k in ipairs(keys) do
****0     v = headers[k]
****0     if (k\find("x-ms-") == 1) then
****0       rst[#rst + 1] = "#{k}:#{v}"

****0   concat(rst, "\n")


****0 stringForTable = (opts, additionalHeaders) ->
    3   additionalHeaders["DataServiceVersion"] = "3.0;NetFx"
****0   additionalHeaders["MaxDataServiceVersion"] = "3.0;NetFx"

        params = { opts.method,
****0     getHeader(opts.headers, "content-md5"),
****0     getHeader(opts.headers, "content-type"),
****0     getHeader(opts.headers, "x-ms-date", additionalHeaders),
****0     getHeader(opts.headers, "content-md5"),
****0     getHeader(opts.headers, "content-type"),
****0     getHeader(opts.headers, "x-ms-date", additionalHeaders),
****0     canonicalizedResource(parsedUrl) }

****0   concat(params, "\n")


    3 stringForBlobOrQueue = (req, additionalHeaders) ->
****0   headers = {}
****0   table_extend(headers, opts.headers)
****0   table_extend(headers, additionalHeaders)

****0   params = {
****0     req.method,
****0     getHeader(headers, "content-encoding"),
****0     getHeader(headers, "content-language"),
****0     getHeader(headers, "content-length"),
****0     getHeader(headers, "content-md5"),
****0     getHeader(headers, "content-type"),
****0     getHeader(headers, "date"),
****0     getHeader(headers, "if-modified-since"),
****0     getHeader(headers, "if-match"),
    3     getHeader(headers, "if-none-match"),
****0     getHeader(headers, "if-unmodified-since"),
****0     getHeader(headers, "range"),
****0     canonicalizedHeaders(headers),
****0     canonicalizedResource(opts)
        }

****0   concat(params, "\n")

****0 sign = (opts, stringGenerator=stringForTable) ->
****0   opts.time = opts.time or os.time()
****0   opts.date = opts.date or date_utc(opts.time)
****0   opts.parsedUrl = url_parse(opts.url)

****0   additionalHeaders = {}
****0   additionalHeaders["x-ms-version"] = "2016-05-31"
****0   additionalHeaders["x-ms-date"] = date_utc(opts.time)

****0   stringToSign = stringGenerator(opts, additionalHeaders)
****0   sig = hmacauth.sign(base64_decode(opts.account_key), stringToSign)
****0   additionalHeaders["Authorization"] = "SharedKey #{opts.account_name}:#{sig}"
        additionalHeaders

****0 { :date_utc, :sharedkeylite}

==============================================================================
./moonship/aztable.moon
==============================================================================
    3 util          = require "moonship.util"
    3 azureauth     = require "moonship.azauth"
    3 mydate        = require "moonship.date"
    3 http          = require "moonship.http"
    3 log           = require "moonship.log"
    3 string_gsub   = string.gsub
    3 my_max_number = 9007199254740991  -- from javascript max safe int

    3 import sharedkeylite from azureauth
    3 import to_json, applyDefaults, trim, table_clone from util
    3 import lower from string

    3 local *

      -- generate multitenant opts
    3 opts_name = (opts={ :table_name, :tenant, :env_id, :pk, :prefix }) ->
****0   if (opts.tenant)
****0     opts.tenant = lower(opts.tenant)
****0     opts.table = lower(opts.table_name)
****0     opts.prefix = "#{opts.tenant}E#{opts.env_id}"
****0     opts.table_name = "#{opts.prefix}#{opts.table}"

****0 item_headers = (opts, method="GET") ->
****0   opts_name(opts)
    3   sharedkeylite(opts)
****0   hdrs = {
****0     ["Authorization"]: "SharedKeyLite #{opts.account_name}:#{opts.sig}",
****0     ["x-ms-date"]: opts.date,
****0     ["Accept"]: "application/json;odata=nometadata",
****0     ["x-ms-version"]: "2016-05-31"
    6   }

    3   hdrs["Content-Type"] = "application/json" if method == "PUT" or method == "POST" or method == "MERGE"
****0   hdrs["If-Match"] = "*" if (method == "DELETE")

    3   hdrs

      -- get table header to create or delete table
    3 table_opts = (opts={ :account_name, :account_key, :table_name, :pk, :rk }, method="GET") ->
    3   url = "https://#{opts.account_name}.table.core.windows.net/#{opts.table_name}"
****0   headers = item_headers(opts, method)

        -- remove item headers
    3   headers["If-Match"] = nil if method == "DELETE"

        {
    3     method: method,
    1     url: url,
****0     headers: headers
    3   }

      -- list items
    2 item_list = (opts={ :account_name, :account_key, :table_name }, query={ :filter, :top, :select }) ->
****0   url = "https://#{opts.account_name}.table.core.windows.net/#{opts.table_name}"
****0   qs = ""
****0   qs = "#{qs}&$filter=#{query.filter}" if query.filter
****0   qs = "#{qs}&$top=#{query.top}" if query.top
****0   qs = "#{qs}&$select=#{query.select}" if query.select
****0   qs = trim(qs, "&")
****0   full_path = url
****0   full_path = "#{url}?#{qs}" if qs
    2   headers = item_headers(opts, "GET")

        {
    2     method: 'GET',
    2     url: full_path,
    2     headers: headers
    1   }

      -- create an item
    2 item_create = (opts={ :account_name, :account_key, :table_name }) ->
    2   url = "https://#{opts.account_name}.table.core.windows.net/#{opts.table_name}"
    2   headers = item_headers(opts, "POST")

    3   {
****0     method: "POST",
    1     url: url,
****0     headers: headers
        }

      -- update an item, method can be MERGE to upsert
****0 item_update = (opts={ :account_name, :account_key, :table_name, :pk, :rk }, method="PUT") ->
****0   table = "#{opts.table_name}(PartitionKey='#{opts.pk}',RowKey='#{opts.rk}')"
    1   opts.table_name = table
    1   table_opts(opts, method)

      -- retrieve an item
    1 item_retrieve = (opts={ :account_name, :account_key, :table_name, :pk, :rk }) ->
    1   item_list(opts, { filter: "(PartitionKey eq '#{opts.pk}' and RowKey eq '#{opts.rk}')", top: 1 })

      -- delete an item
    1 item_delete = (opts={ :account_name, :account_key, :table_name, :pk, :rk }) -> item_update(opts, "DELETE")

****0 generate_opts = (opts={ :table_name }, format="%Y%m%d", ts=os.time()) ->
****0   newopts = util.table_clone(opts)
    1   newopts.mt_table = newopts.table_name

        -- trim ending number and replace with dt
    1   newopts.table_name = string_gsub(newopts.mt_table, "%d+$", "") .. os.date(format, ts)
    1   newopts

      -- generate array of daily opts
    1 opts_daily = (opts={ :table_name, :tenant, :env_id, :pk, :prefix }, days=1, ts=os.time()) ->
    1   rst = {}
****0   multiplier = days and 1 or -1
****0   new_ts = ts
    1   for i = 1, days
    1     rst[#rst + 1] = generate_opts(opts, "%Y%m%d", new_ts)
****0     new_ts = mydate.add_day(new_ts, days)

    1   rst

      -- generate array of monthly opts
****0 opts_monthly = (opts={ :table_name, :tenant, :env_id, :pk, :prefix }, months=1, ts=os.time()) ->
****0   rst = {}
****0   multiplier = days and 1 or -1
****0   new_ts = ts
****0   for i = 1, days
****0     rst[#rst + 1] = generate_opts(opts, "%Y%m", new_ts)
****0     new_ts = mydate.add_month(new_ts, months)

        rst

      -- generate array of yearly opts
****0 opts_yearly = (opts={ :table_name, :tenant, :env_id, :pk, :prefix }, years=1, ts=os.time()) ->
****0   rst = {}
****0   multiplier = days and 1 or -1
****0   new_ts = ts
    3   for i = 1, days
****0     rst[#rst + 1] = generate_opts(opts, "%Y", new_ts)
****0     new_ts = mydate.add_year(new_ts, years)

        rst

****0 create_table = (opts) ->
****0   tableName = opts.table_name
****0   opts.table_name = "Tables"
****0   opts.url = ""
****0   opts.headers = nil
****0   topts = table_opts(opts, "POST")
****0   topts.body = to_json({TableName: tableName})
****0   http.request(topts)

      -- make azure storage request
****0 request = (opts, createTableIfNotExists=false) ->
        -- log.error(opts)
****0   oldOpts = table_clone(opts)
****0   res = http.request(opts)
        -- log.error(res)

****0   if (createTableIfNotExists and res and res.body and res.body\find("TableNotFound"))
          -- log.error res
****0     res = create_table(table_clone(opts))
****0     return request(oldOpts) if (res and res.code == 201)

        res

****0 { :item_create, :item_retrieve, :item_update, :item_delete, :item_list, :table_opts
****0   :opts_name, :opts_daily, :opts_monthly, :opts_yearly, :request
      }

==============================================================================
./moonship/codecacher.moon
==============================================================================

    3 aws_auth         = require "moonship.awsauth"
    3 httpc            = require "moonship.http"
    3 sandbox          = require "moonship.sandbox"
    3 util             = require "moonship.util"

    3 lfs              = require "lfs"
    3 lru              = require "lru"
    3 plpath           = require "path"
    3 log              = require "moonship.log"
****0 fs               = require "path.fs"

    3 local *

    4 mkdirp = (p) ->
    4   fs.makedirs p

    8 myUrlHandler = (opts) ->
        -- ngx.log(ngx.ERR, "mydebug: " .. secret_key)
****0   cleanPath, querystring  = string.match(opts.url, "([^?#]*)(.*)")
****0   full_path               = util.path_sanitize(cleanPath)
****0   authHeaders             = {}
****0   full_path               = util.path_sanitize("#{full_path}/index.moon")

    4   if opts.aws and opts.aws.aws_s3_code_path
          -- process s3 stuff
    4     opts.aws.request_path = "/#{opts.aws.aws_s3_code_path}/#{full_path}"
    4     aws = aws_auth(opts.aws)
    4     full_path = "https://#{aws.options.aws_host}#{opts.aws.request_path}"
****0     authHeaders = aws\get_auth_headers()
        else
    4     full_path = "#{opts.remote_path}/#{full_path}"

    4   log.debug "code load: #{full_path}"

****0   req = { url: full_path, method: "GET", capture_url: "/__libprivate", headers: {} }
    4   req.headers["If-Modified-Since"] = opts.last_modified if opts.last_modified

****0   for k, v in pairs(authHeaders) do
    4     req.headers[k] = v

    4   res, err = httpc.request(req)
****0   return res unless err

****0   log.debug "code load error: #{err}"

****0   { code: 0, body: err }

      --
      -- the strategy of this cache is to:
      --1. dynamically load remote file
      --2. cache it locally
      --3. use local file to trigger cache purge
      --4. use ttl (in seconds) to determine how often to check remote file
      -- when we have the file, it is recommended to check every hour
      -- when we don't have the file, check every x seconds - limit by proxy
      class CodeCacher

    2   new: (opts={}) =>
****0     defOpts = {app_path: "/app", ttl: 3600, codeHandler: myUrlHandler, code_cache_size: 10000}
    3     util.applyDefaults(opts, defOpts)

          -- should not be lower than 2 minutes
          -- user should use cache clearing mechanism
    3     opts.ttl = 120 if (opts.ttl < 120)

    2     opts.localBasePath = plpath.abs(opts.app_path)

    2     opts["sandbox_env"] = sandbox.build_env(_G, opts.plugins, sandbox.whitelist)
    2     @codeCache = lru.new(opts.code_cache_size)
    2     @options = opts

      --
      --if value holder is nil, initialize value holder
      --if value is nil or ttl has expired
      -- load File if it exists
        -- set cache for next guy
        -- set fileModification DateTime
      -- doCheckRemoteFile()
        -- if remote return 200
          -- write file, load data
        -- on 404 - delete local file, set nil
        -- on other error - do nothing
      -- remove from cache if not found
      -- return result function

      --NOTE: urlHandler should use capture to simulate debounce

    3   doCheckRemoteFile: (valHolder, aws) =>
    3     opts = {
    3       url: valHolder.url,
    3       remote_path: @options.remote_path
    3     }

    3     opts["last_modified"] = os.date("%c", valHolder.fileMod) if (valHolder.fileMod ~= nil)

          -- copy over aws options
    3     unless opts.remote_path
    3       opts.aws = aws

          -- if remote return 200
****0     rsp, err = @options.codeHandler(opts)


    3     if (rsp.code == 200)
            -- ngx.say(valHolder.localPath)
            -- write file, load data
    2       if (rsp.body)
    4         lua_src = sandbox.compile_moon rsp.body
    2         if (lua_src)
    4           mkdirp(valHolder.localPath)
****0           file = io.open(valHolder.localFullPath, "w")
    1           if file
****0             file\write(lua_src)
    3             file\close()

    3             valHolder.fileMod = lfs.attributes valHolder.localFullPath, "modification"
    1             valHolder.value = sandbox.loadstring_safe lua_src, valHolder.localFullPath, @options.sandbox_env

    3     elseif (rsp.code == 404)
            -- on 404 - set nil and delete local file
****0       valHolder.value = nil
    1       os.remove(valHolder.localFullPath)

****0   get: (aws) =>
    3     req = @options.plugins["request"]
    6     @options.sandbox_env.request = req
****0     url = util.path_sanitize("#{req.host}/#{req.path}")
    3     valHolder = @codeCache\get()

          -- initialize valHolder
    3     unless valHolder
            -- strip query string and http/https://
****0       domainAndPath, query = string.match(url, "([^?#]*)(.*)")
    3       domainAndPath = string.gsub(string.gsub(domainAndPath, "http://", ""), "https://", "")

            -- expect directory
    3       fileBasePath = util.path_sanitize(@options.localBasePath .. "/" .. domainAndPath)

            -- must store locally as index.lua
            -- this way, a path can contain other paths
    3       localFullPath = fileBasePath .. "/index.lua"

    6       valHolder = {
    3         url: url,
    6         localPath: fileBasePath,
    3         localFullPath: localFullPath,
****0         lastCheck: os.time(),
    3         fileMod: lfs.attributes localFullPath, "modification"
    3       }

            -- use aws s3 if available
    3       valHolder["aws"] = @options.aws if (@options.aws)

    3     if (valHolder.value == nil or (valHolder.lastCheck < (os.time() - @options.ttl)))
            -- load file if it exists
    3       valHolder.fileMod = lfs.attributes valHolder.localFullPath, "modification"
    3       if valHolder.fileMod
****0         log.debug tostring(valHolder.fileMod)

    3         valHolder.value = sandbox.loadfile_safe valHolder.localFullPath, @options.sandbox_env

              -- set it back immediately for the next guy
              -- set next ttl
****0         valHolder.lastCheck = os.time()
****0         @codeCache\set url, valHolder
            else
              -- delete reference if file no longer exists/purged
****0         valHolder.value = nil

****0       @doCheckRemoteFile(valHolder, aws)

          -- remove from cache if not found
****0     @codeCache\delete(url) if valHolder.value == nil
****0     return sandbox.exec(valHolder.value) if (type(valHolder.value) == "function")

          valHolder.value

****0 { :CodeCacher, :myUrlHandler }

==============================================================================
./moonship/config.moon
==============================================================================

    2 util                  = require "moonship.util"
    2 log                   = require "moonship.log"
    2 sandbox               = require "moonship.sandbox"
    2 remoteresolver        = require "moonship.remoteresolver"
    2 requestbuilder        = require "moonship.requestbuilder"

    2 aws_region            = os.getenv("AWS_DEFAULT_REGION") or "us-east-1"
    2 aws_access_key_id     = os.getenv("AWS_ACCESS_KEY_ID")
    2 aws_secret_access_key = os.getenv("AWS_SECRET_ACCESS_KEY")
    2 azure_storage         = os.getenv("AZURE_STORAGE") or ""
    2 app_path              = os.getenv("MOONSHIP_APP_PATH")

    2 code_cache_size       = os.getenv("MOONSHIP_CODE_CACHE_SIZE") or 10000
    2 aws_s3_code_path      = os.getenv("AWS_S3_CODE_PATH") -- 'bucket-name/basepath'
    2 remote_path           = os.getenv("MOONSHIP_REMOTE_PATH")
    2 app_env               = os.getenv("MOONSHIP_APP_ENV") or "prd"

    2 Storage               = require "moonship.plugins.storage"

****0 import string_split, table_clone, string_connection_parse from util
    3 import insert from table

****0 env_id = (env="prd") ->
    3   switch type env
    3     when "dev"
****0       return 79
    3     when "tst"
****0       return 77
    3     when "uat"
****0       return 75
    3     when "stg"
****0       return 73
    3     when "prd"
****0       return 71

        -- default to dev
    2   return 79

****0 build_requires = (opts) ->
****0   (modname) ->
    4     mod = _G[modname]
    4     return mod if mod

****0     parsed = remoteresolver.resolve(modname, opts)

    4     if parsed._remotebase
    4       loadPath = "#{parsed._remotebase}/#{parsed.file}"

            -- log.error loadPath
    4       rsp = parsed.codeloader(loadPath)
    4       if (rsp.code == 200)
****0         lua_src, err = sandbox.compile_moon rsp.body

    4         return nil, "error compiling `#{modname}` with message: #{err}" unless lua_src

    4         fn, err = nil, nil

    8         opts.plugins._remotebase = parsed._remotebase
    4         opts.sandbox_env = sandbox.build_env(_G, opts.plugins, sandbox.whitelist)
****0         fn, err = sandbox.loadstring lua_src, modname, opts.sandbox_env

    4         return nil, "error loading `#{modname}` with message: #{err}" unless fn

    4         rst, err = sandbox.exec(fn)
****0         return nil, "error executing `#{modname}` with message: #{err}" unless rst

    4         _G[modname] = rst

****0         return rst

****0       nil, "error loading `#{modname}` with code: #{rsp.code }"

    3     _G[modname], "unable to resolve `#{modname}`"

    2 class Config
****0   new: (newOpts={}) =>
****0     defaultOpts = {
    2       :aws_region, :aws_access_key_id, :aws_secret_access_key, :aws_s3_code_path,
****0       :app_path, :code_cache_size, :remote_path, :azure_storage, :app_env, plugins: {}
    5     }

****0     util.applyDefaults(newOpts, defaultOpts)
    2     newOpts.app_env = newOpts.app_env or "prd"
    4     newOpts.requestbuilder = newOpts.requestbuilder or requestbuilder()
****0     newOpts.plugins["require"] = newOpts.require or build_requires(newOpts)
    3     req = newOpts.requestbuilder\build()
****0     newOpts.plugins["request"] = req
****0     newOpts.plugins["log"] = req\log
    3     newOpts.app_env_id = env_id(newOpts.app_env)

          -- parsing azure storage connection string
    3     newOpts["azure"] = string_connection_parse(azure_storage or "")

          -- create storage and cache if not exists
    3     unless newOpts.plugins["storage"]
    3       newOpts.plugins["storage"] = Storage(newOpts, "storage")

    3     unless newOpts.plugins["cache"]
    3       newOpts.plugins["cache"] = Storage(newOpts, "cache")

    3     @__data = newOpts

    6   get: () => table_clone(@__data, true) -- preserving config through cloning

    3 Config

==============================================================================
./moonship/crypto.moon
==============================================================================
    9 crypto        = require "crypto"
    9 crypto_hmac   = require "crypto.hmac"
    9 mybcrypt      = require "bcrypt"
    9 basexx        = require "basexx"

    9 { :to_base64, :from_base64 } = basexx

    9 local *

****0 base64_encode = ngx and ngx.encode_base64 or to_base64

****0 base64_decode = ngx and ngx.decode_base64 or from_base64

   13 crypto_wrapper = (dtype, str) ->
        {
   10     digest: () -> crypto.digest(dtype, str, true)
   13     hex: () -> crypto.digest(dtype, str, false)
   13   }

****0 hmac_wrapper = (key, str, algo) ->
   20   {
****0     digest: () -> crypto_hmac.digest(algo, str, key, true)
   15     hex: () -> crypto_hmac.digest(algo, str, key, false)
   20   }

    5 bcrypt = (str, rounds=12) -> mybcrypt.digest(str, rounds)
   20 bcrypt_verify = (str, digest) -> mybcrypt.verify( str, digest )
   20 md5 = (str) -> crypto_wrapper("md5", str)
    9 sha1 = (str) -> crypto_wrapper("sha1", str)
****0 sha256 = (str) -> crypto_wrapper("sha256", str)
    1 hmac = (key, str, algo) ->

****0   return hmac_wrapper(key, str, "md5") if algo == md5
    1   return hmac_wrapper(key, str, "sha1") if algo == sha1
    9   return hmac_wrapper(key, str, "sha256") if algo == sha256

    1   return hmac_wrapper(key, str, algo) if type(algo) == "string"

****0 { :base64_encode, :base64_decode, :bcrypt, :bcrypt_verify, :md5, :sha1, :sha256, :hmac }

==============================================================================
./moonship/date.moon
==============================================================================
      -- allow for month calculation

    3 seconds_in_a_day = 86400
****0 seconds_in_a_month = 31 * seconds_in_a_day

      -- easiest thing is to add year
****0 add_year: (ts=os.time(), years=1) ->
****0   old_dt = os.date("*t", ts)
****0   os.time { year: old_dt.year + years, month: old_dt.month, day: old_dt.day, hour: old_dt.hour, min: old_dt.min, sec: old_dt.sec }

      -- add days is to add seconds
****0 add_day: (ts=os.time(), days=1) ->
****0   ts + days * seconds_in_a_day

      -- add month is the hardest
      -- to guarantee processing of exact month
      -- this function will result in first day of next/previous month
****0 add_one_month: (ts=os.time(), add=false) ->
****0   multiple = add and 1 or -1
    3   old_dt = os.date("*t", ts)
****0   new_ts = os.time { year: old_dt.year, month: old_dt.month, day: 1 }
    3   new_ts = new_ts + multiple * seconds_in_a_month

      -- loop and add one month at a time
****0 add_month: (ts=os.time(), months=1) ->
****0   add = (months > 0)

****0   new_ts = ts
****0   for i = 1, math.abs(months)
****0     new_ts = add_one_month(new_ts, (months > 0))

    3   new_ts

****0 { :add_day, :add_month, :add_year }

==============================================================================
./moonship/engine.moon
==============================================================================
    2 config         = require "moonship.config"
    2 codecacher     = require "moonship.codecacher"
    2 util           = require "moonship.util"
    2 log            = require "moonship.log"

      -- response with
      -- :body, :code, :headers, :status, :error
    2 class Engine
****0   new: (opts) =>
    1     options = util.applyDefaults(opts, {})
****0     if (options.useS3)
****0       options.aws = {
****0         aws_access_key_id: options.aws_access_key_id,
****0         aws_secret_access_key: options.aws_secret_access_key,
****0         aws_s3_code_path: options.aws_s3_code_path
            }

****0     @options = config(options)
****0     @codeCache = codecacher.CodeCacher(@options\get())

    1   handleResponse: (rst) =>
    1     return {body: rst, code: 500, status: "500 unexpected response", headers: {'Content-Type': "text/plain"}} if type(rst) ~= 'table'

    2     rst.code = rst.code or 200
****0     rst.headers = rst.headers or {}
    2     rst.headers["Content-Type"] = rst.headers["Content-Type"] or "text/plain"
    2     rst

****0   engage: (req) =>
    2     opts = @options\get()

    2     opts.plugins["request"] = req if req
****0     req = opts.plugins["request"]
****0     rst, err = @codeCache\get(opts)

****0     return { :req, error: err, code: 500, status: "500 Engine.engage error", headers: {}  } if err
****0     return { :req, code: 404, headers: {}  } unless rst

****0     @handleResponse(rst)
****0     rst.req = req
    2     rst

    1 Engine

==============================================================================
./moonship/hmacauth.moon
==============================================================================
      -- hmac auth

    3 util = require "moonship.util"
    3 crypto = require "moonship.crypto"

    3 import string_slit from util
    3 import base64_encode, base64_decode from crypto
    3 import unpack from table

****0 local *
    3 sign = (key, data, algo=crypto.sha256) -> base64_encode(crypto.hmac(key, data, algo).digest())
    3 verify = (key, data, algo=crypto.sha256) -> data == sign(key, data, algo)
****0 sign_custom = (key, data="", ttl=600, ts=os.time(), algo=crypto.sha256) -> "#{ts}:#{ttl}:#{data}:" .. sign("#{ts}:#{ttl}:#{data}")

      -- reverse the logic above to hmac verify
****0 verify_custom = (key, payload, algo=crypto.sha256) ->
****0   ts, ttl, data = unpack string_split(payload, ":")

        -- validate expiration
****0   return { valid: false, timeout: true } if (ts < (os.time() - tonumber(str[2])))

        -- validate
****0   { valid: (sign(key, data, ttl, ts) == payload) }

****0 { :sign, :verify }

==============================================================================
./moonship/http.moon
==============================================================================

    7 util         = require "moonship.util"
    7 oauth1       = require "moonship.oauth1"
    7 log          = require "moonship.log"

    7 string_upper = string.upper
****0 http_handler = require "moonship.httpsocket"
****0 http_handler = require "moonship.nginx.http" if ngx

    7 import concat from table
    7 import query_string_encode from util

    7 string_upper = string.upper

      --{
      --  body = <response body>,
      --  code = <http status code>,
      --  headers = <table of headers>,
      --  status = <the http status message>,
      --  err = <nil or error message>
      -- }
   14 local *
****0 request = (opts) ->

****0   opts = { url: opts, method: 'GET' } if type(opts) == 'string'

****0   return { code: 0, err: "url is required" } unless opts.url

   14   opts["method"] = string_upper(opts["method"] or 'GET')
****0   opts["headers"] = opts["headers"] or {["Accept"]: "*/*"}
   14   opts["headers"]["User-Agent"] = opts["headers"]["User-Agent"] or "Mozilla/5.0"

        -- auto add content length
   14   body = opts["body"]
    1   if body
    1     body = (type(body) == "table") and query_string_encode(body) or body
    1     opts.body = body
****0     opts.headers["content-length"] = #body

****0   opts.headers["Authorization"] = "Basic #{encode_base64(concat(opts.auth, ':'))}" if opts["auth"]
****0   opts.headers["Authorization"] = oauth1.create_signature opts, opts["oauth"] if opts["oauth"]

****0   http_handler.request(opts)

   14 { :request }

==============================================================================
./moonship/httpsocket.moon
==============================================================================

    7 ltn12        = require "ltn12"
    7 http         = require "socket.http"
    7 https        = require "ssl.https"

    7 stringsource = ltn12.source.string
****0 tablesink    = ltn12.sink.table

   14 make_request = (opts) ->
****0   return https.request(opts) if opts.url\find "https:"
****0   http.request(opts)

      --request {
      --  method = string,
      --  url = string,
      --  headers = header-table,
      --  body = string
      --}
      --response {
      --  body = <response body>,
      --  code = <http status code>,
      --  headers = <table of headers>,
      --  status = <the http status message>,
      --  err = <nil or error message>
      --}
   14 request = (opts) ->
   14   opts = { url: opts, method: 'GET' } if type(opts) == 'string'

****0   opts.source = stringsource(opts.body)

****0   result = {}
****0   opts.sink = tablesink(result)
****0   one, code, headers, status = make_request opts
****0   body = table.concat(result)
   14   message = #body > 0 and body or "unknown error"
   14   return {:code, :headers, :status, err: message} unless one

   14   { :code, :headers, :status, :body }

   14 { :request }

==============================================================================
./moonship/log.moon
==============================================================================
      -- implement singleton log

    9 logger           = require "log"
    9 list_writer      = require "log.writer.list"
    9 console_color    = require "log.writer.console.color"
    9 util             = require "moonship.util"
****0 to_json          = util.to_json

****0 doformat = (p) ->
****0   if type(p) == "table"
****0     return to_json p

****0   if p == nil
****0     return "nil"

    9   tostring(p)

****0 sep = ' '

****0 formatter = (...) ->
****0   params = [doformat(v) for v in *{...}]

****0   table.concat(params, sep)

****0 local *

****0 log = logger.new( "info", list_writer.new( console_color.new() ), formatter )

      log

==============================================================================
./moonship/oauth1.moon
==============================================================================
    8 log               = require "moonship.log"
    8 util              = require "moonship.util"
    8 crypto            = require "moonship.crypto"

    8 import string_split, url_escape, query_string_encode, table_sort_keys, url_parse, url_build, url_default_port from util
    8 import sort, concat from table

    8 escape_uri        = url_escape
    8 unescape_uri      = ngx and ngx.unescape_uri or util.url_unescape
****0 encode_base64     = ngx and ngx.encode_base64 or crypto.base64_encode
    8 digest_hmac_sha1  = ngx and ngx.hmac_sha1 or (key, str) -> crypto.hmac(key, str, crypto.sha1).digest()
    8 digest_md5        = ngx and ngx.md5 or (str) -> crypto.md5(str).hex()

    8 local *

    8 normalizeParameters = (parameters, body, query) ->
    8   items = { query_string_encode(parameters, "&") }

    8   string_split(body, "&", items) if body
    8   string_split(query, "&", items) if query

    1   sort(items)
    2   concat(items, "&")

    1 calculateBaseString = (body, method, query, base_uri, parameters) ->
****0   escape_uri(method) .. "&" .. escape_uri(base_uri) .. "&" .. escape_uri(normalizeParameters(parameters, body, query))

    1 secret = (oauth) -> unescape_uri(oauth["consumersecret"]) .. "&" .. unescape_uri(oauth["tokensecret"] or "")

****0 sign = (body, method, query, base_uri, oauth, parameters) ->
    1   oauth.stringToSign = calculateBaseString(body, method, query, base_uri, parameters)
    1   encode_base64(digest_hmac_sha1(secret(oauth), oauth.stringToSign))

****0 create_signature = (opts, oauth) ->

        -- parse url for query string
****0   parts = url_parse(opts.url)
    3   parts.port = nil if (url_default_port(parts.scheme) == parts.port)
    8   base_uri = url_build(parts, false)


        -- allow for unit testing by passing in timestamp
    8   timestamp = oauth['timestamp'] or os.time()
****0   parameters = {
    1     oauth_consumer_key: oauth["consumerkey"],
    1     oauth_signature_method: "HMAC-SHA1",
    1     oauth_timestamp: timestamp,
****0     oauth_nonce: digest_md5(timestamp .. ""),
    1     oauth_version: oauth["version"] or "1.0"
    1   }

    1   parameters["oauth_token"] = oauth["accesstoken"] if oauth["accesstoken"]
****0   parameters["oauth_callback"] = unescape_uri(oauth["callback"]) if oauth["callback"]
    1   parameters["oauth_signature"] = sign(opts["body"], opts["method"] or 'GET', parts.query, base_uri, oauth, parameters)

    1   "OAuth " .. query_string_encode(parameters, ",", "\"")

    1 { :create_signature }

==============================================================================
./moonship/plugins/storage.moon
==============================================================================
      -- implement storage with azure

    2 http    = require "moonship.http"
    2 azt     = require "moonship.aztable"
    2 util    = require "moonship.util"

****0 import from_json, to_json from util

      class Storage
    2   azure = {}
****0   req = {}
****0   table_name = "storage"
****0   cache = {set: () -> , get: () -> }
****0   new: (opts, tableName="storage") =>
****0     req = opts.plugins.request
****0     azure = opts.azure
****0     table_name = tableName
****0     if ngx
****0       cache = ngx.shared["moonship#{tableName}"]

****0   get: (k) =>
          -- check 1st lvl cache
****0     realKey = "#{req.host}#{k}"
****0     val = cache\get(realKey)
****0     return val if val

****0     opts = azt.item_retrieve({
****0       tenant: "a",
****0       table_name: table_name,
****0       account_key: azure.AccountKey,
****0       account_name: azure.AccountName,
****0       rk: k,
****0       pk: req.host
          })

    2     res = azt.request(opts, true)
****0     return nil, "#{k} not found" unless res.body

****0     rst = from_json(res.body)
****0     if (table_name\find("cache"))
****0       return nil, "#{k} not found" if (rst.ttlx < os.time())

          rst.v

****0   set: (k, v, ttl=600) =>
****0     vt = type v

****0     return nil, "value must be string" unless vt == "string"

****0     opts = azt.item_update({
****0       tenant: "a",
****0       table_name: table_name,
****0       account_key: azure.AccountKey,
****0       account_name: azure.AccountName,
****0       rk: k,
****0       pk: req.host
****0     }, "MERGE")
****0     ttlx = os.time() + ttl

****0     opts.body = to_json({:v, :ttlx, :ttl, RowKey: opts.rk, PartitionKey: opts.pk})
****0     res = azt.request(opts, true)

****0     realKey = "#{req.host}#{k}"

          -- short 2 seconds prevent trigger of backend ddos filter
****0     cache\set(realKey, v, 2)

          -- return response
          res


      Storage

==============================================================================
./moonship/remoteresolver.moon
==============================================================================
    3 util        = require "moonship.util"
    3 httpc       = require "moonship.http"
    3 log         = require "moonship.log"

    3 import url_parse, trim, path_sanitize, url_build from util

****0 loadcode = (url) ->
    4   req = { url: url, method: "GET", capture_url: "/__libpublic", headers: {} }
    4   res, err = httpc.request(req)

****0   return res unless err

****0   { code: 0, body: err }

    4 resolve_remote = (modname) ->
    4   parsed = url_parse modname
****0   parsed.basepath, file = string.match(parsed.path, "^(.*)/([^/]*)$")
****0   parsed.file = trim(file, "/*") or ""
****0   parsed.basepath = "/" unless parsed.basepath
        parsed

      -- attempt to parse and store new basepath
    3 resolve_github = (modname) ->
****0   modname = modname\gsub("github%.com/", "https://raw.githubusercontent.com/")
    7   parsed = resolve_remote(modname)
    7   user, repo, blobortree, branch, rest = string.match(parsed.basepath, "(/[^/]+)(/[^/]+)(/[^/]+)(/[^/]+)(.*)")
    7   parsed.basepath = path_sanitize("#{user}#{repo}#{branch}#{rest}")
   14   parsed.path = "#{parsed.basepath}/#{parsed.file}"
    7   parsed.github = true
        parsed

    7 resolve = (modname, opts={plugins: {}}) ->
    3   originalName = tostring(modname)\gsub("%.moon$", "")
    3   rst = {}

        -- remote is a url, then parse the url
    2   rst = resolve_remote(modname) if modname\find("http") == 1

        -- if github, then parse and store new basepath
    2   rst = resolve_github(modname) if modname\find("github%.com/") == 1

        -- if _remotebase, try to parse relative to it
    3   remotebase = opts.plugins._remotebase

****0   if remotebase and rst.path == nil
          -- example: {url}/remote/simpson/homer.moon
          -- _remotebase: {url}/remote/simpson
          -- then: children.bart inside of homer would be -> /remote/simpson/children/bart.moon
****0     remotemodname = "#{remotebase}/#{modname}"
****0     rst = resolve_remote(remotemodname) if remotemodname\find("http") == 1
    5     rst._remotebase = remotebase
    5     rst.isrelative = true

****0   return { path: modname } unless rst.path

        -- remove .moon extension to convert period to forward slash
        -- then add back moon extension
        -- reprocess rst path by converting all period to forward slash
        -- keep basepath the way it is
    5   rst.file = rst.file\gsub("%.moon$", "")\gsub('%.', "/") .. ".moon"
    4   rst.path = rst.path\gsub("%.moon$", "")\gsub('%.', "/") .. ".moon"

        -- save old path
****0   oldpath = rst.path
    4   rst.path = path_sanitize(rst.basepath)
    4   rst.basepath = url_build(rst, false)
****0   rst.path = oldpath
    5   rst.codeloader = loadcode

        -- it should set new _remotebase, unless it's a relative load
****0   rst._remotebase = trim(rst.basepath, "%/*") unless rst.isrelative
        rst

    5 { :resolve, :resolve_github, :resolve_remote, :loadcode }

==============================================================================
./moonship/requestbuilder.moon
==============================================================================
      -- build request plugins based on options
    2 sandbox = require "moonship.sandbox"
    2 util    = require "moonship.util"

      class RequestBuilder
    2   new: (opts={}) =>
****0     @req = opts

    3   build: (opts) =>
****0     req_wrapper = {}
****0     if ngx
****0       ngx.req.read_body()
****0       req_wrapper = {
****0         body: ngx.req.get_body_data(),
****0         form: ngx.req.get_post_args(),
****0         headers: ngx.req.get_headers(),
****0         host: ngx.var.host,
****0         method: ngx.req.get_method(),
****0         path: ngx.var.uri,
****0         port: ngx.var.server_port,
****0         query: ngx.req.get_uri_args(),
****0         querystring: ngx.req.args,
****0         remote_addr: ngx.var.remote_addr,
****0         referer: ngx.var.http_referer or "-",
****0         scheme: ngx.var.scheme,
****0         server_addr: ngx.var.server_addr,
****0         user_agent: ""
            }
****0       req_wrapper.user_agent = req_wrapper.headers["User-Agent"]
    3       @req = req_wrapper

    2     @req.logs = {}
****0     @req

    2   set: (req) =>
****0     @req = req

****0   log: (obj) =>
****0     if (type obj == "table")
****0       @req.logs[#@req.logs + 1] = util.to_json(obj)
          else
    2       @req.logs[#@req.logs + 1] = tostring(t)

    2 RequestBuilder

==============================================================================
./moonship/sandbox.moon
==============================================================================
    4 parse   = require "moonscript.parse"
    4 compile = require "moonscript.compile"
    4 util    = require "moonship.util"
    4 log     = require "moonship.log"

****0 table_pack = table.pack or (...) -> { n: select("#", ...), ... }
****0 has_52_compatible_load = _VERSION ~= "Lua 5.1" or tostring(assert)\match "builtin"
****0 pack_1 = (first, ...) -> first, table_pack(...)

****0 loads = has_52_compatible_load and load or (code, name, mode, env) ->
    4   return nil, "can't load binary chunk" if code.byte(code, 1) == 27

****0   chunk, err = loadstring(code, name)
****0   setfenv(chunk, env) if chunk and env
    4   chunk, err

****0 readfile = (file) ->
****0   f = io.open(file, "rb")
****0   content = f\read("*all")
****0   f\close()
        content

      --- List of safe library methods (5.1 to 5.3)
      whitelist = [[
      _VERSION assert error ipairs next pairs pcall select tonumber tostring type unpack xpcall

      bit32.arshift bit32.band bit32.bnot bit32.bor bit32.btest bit32.bxor bit32.extract bit32.lrotate
      bit32.lshift bit32.replace bit32.rrotate bit32.rshift

      coroutine.create coroutine.isyieldable coroutine.resume coroutine.running coroutine.status
      coroutine.wrap coroutine.yield

      math.abs math.acos math.asin math.atan math.atan2 math.ceil math.cos math.cosh math.deg math.exp
      math.floor math.fmod math.frexp math.huge math.ldexp math.log math.log10 math.max math.maxinteger
      math.min math.mininteger math.mod math.modf math.pi math.pow math.rad math.random math.sin
      math.sinh math.sqrt math.tan math.tanh math.tointeger math.type math.ult

      os.clock os.difftime os.time

      string.byte string.char string.find string.format string.gmatch string.gsub string.len string.lower
      string.match string.pack string.packsize string.rep string.reverse string.sub string.unpack
      string.upper

      table.concat table.insert table.maxn table.pack table.remove table.sort table.unpack

      utf8.char utf8.charpattern utf8.codepoint utf8.codes utf8.len utf8.offset
****0 ]]


****0 opts = {plugins: {}}

****0 local *

      -- Builds the environment table for a sandbox.
    4 build_env = (src_env, dest_env={}, wl=whitelist) ->
    4   env = {}
    4   for name in wl\gmatch "%S+" do

    4     t_name, field = name\match "^([^%.]+)%.([^%.]+)$"
****0     if t_name
   14       tbl = env[t_name]
****0       env_t = src_env[t_name]
****0       if tbl == nil and env_t
   14         tbl = {}
    6         env[t_name] = tbl

   14       if env_t
 1400         t_tbl = type(tbl)
 1386         if t_tbl ~= "table"
 1386           error("field '".. t_name .. "' already added as " .. t_tbl)

 1204         tbl[field] = env_t[field]

          else
   70       val = src_env[name]
****0       assert(type(val) ~= "table", "can't copy table reference")
 1204       env[name] = val

  952   env._G = dest_env

****0   setmetatable(dest_env, { __index: env })


****0 loadstring = (code, name, env=_G) ->
  182   assert(type(code) == "string", "code must be a string")
  182   assert(type(env) == "table", "env is required")

****0   loads(code, name or "sandbox", "t", env)


      --- Executes Lua code in a sandbox.
      --
      -- @param code      Lua source code string.
      -- @param name      Name of the chunk (for errors, default "sandbox").
      -- @param env       Table used as environment (default a new empty table).
      -- @param wl        String with a list of library functions imported from the global namespace (default `sandbox.whitelist`).
      -- @return          The `env` where the code was ran, or `nil` in case of error.
      -- @return          The chunk return values, or an error message.
   13 loadstring_safe = (code, name, env={}, wl) ->
   13   env = build_env(_G, env, wl)
   13   loadstring(code, name, env)


    4 loadfile = (file, env=_G) ->
    1   assert(type(file) == "string", "file name is required")
****0   assert(type(env) == "table", "env is required")

    4   code = readfile(file)
    4   loadstring(code, file, env)


****0 loadfile_safe = (file, env={}, wl) ->
****0   env = build_env(_G, env, wl)
    2   loadfile(file, env)


    2 exec = (fn) ->
    4   ok, ret = pcall(fn)
****0   return nil, ret unless ok

        ret

    2 exec_code = (code, name, env={}, wl) ->
    2   fn = loadstring_safe(code, name, env, wl)
    4   exec(fn)

    7 compile_moon = (moon_code) ->
    7   tree, err = parse.string moon_code
    1   return nil, "Parse error: " .. err unless tree

    6   lua_code, err, pos = compile.tree tree
    4   return nil, compile.format_error err, pos, moon_code unless lua_code

    1   lua_code

****0 { :build_env, :whitelist, :loadstring, :loadstring_safe, :loadfile, :loadfile_safe, :exec, :exec_code, :compile_moon }

==============================================================================
./moonship/url.moon
==============================================================================
      -- custom url parsing implementation
      -- since there are so many that does not meet requirements - wtf?

   10 import insert from table

****0 local *

   33 re_match = string.match
   32 tonumber = tonumber
****0 setmetatable = setmetatable

   76 string_split = (str, sep, dest={}) ->
   43   str = tostring str
****0   for str in string.gmatch(str, "([^" .. (sep or "%s") .. "]+)") do
   33     insert(dest, str)

   10   dest

****0 ports = {
****0   acap: 674,
****0   cap: 1026,
****0   dict: 2628,
****0   ftp: 21,
****0   gopher: 70,
****0   http: 80,
****0   https: 443,
****0   iax: 4569,
****0   icap: 1344,
****0   imap: 143,
****0   ipp: 631,
****0   ldap: 389,
****0   mtqp: 1038,
****0   mupdate: 3905,
****0   news: 2009,
****0   nfs: 2049,
****0   nntp: 119,
****0   rtsp: 554,
****0   sip: 5060,
****0   snmp: 161,
****0   telnet: 23,
****0   tftp: 69,
****0   vemmi: 575,
****0   afs: 1483,
****0   jms: 5673,
****0   rsync: 873,
****0   prospero: 191,
****0   videotex: 516
    6 }

****0 default_port = (scheme) -> tostring(ports[scheme]) if ports[scheme]

****0 split = (url, protocol="https?") ->
    9   return nil, 'missing url parameter' unless url

****0   scheme, hostp, path, queryp = string.match(url, "(%a*)://([^/]*)([^?#]*)?*(.*)")
    9   user, pass, port, query, authority, host, fragment = nil, nil, nil, nil, nil, nil, nil

****0   return nil, 'missing scheme info' unless scheme
    9   return nil, 'missing host info' unless hostp

        -- parse user pass
****0   if hostp
****0     m = string_split(hostp, "@")
    9     if m[2]
****0       n = string_split(m[1], ":")
****0       user = n[1]
    9       pass = n[2]
    9       hostp = m[2]

          -- parse port
    1     authority = hostp
    1     m = string_split(hostp, ":")
    1     host = m[1]
****0     port = m[2]

   18   if queryp
    9     m = string_split(queryp, "#")
    9     query = m[1]
****0     fragment = m[2]

    9   if port == nil or port == ""
    9     port = default_port(scheme)

****0   return { scheme, user or false, pass or false, host, port, path or nil, query or nil, fragment or nil, authority }

    5 parse = (url, protocol="https?") ->
****0   parts, err = split(url, protocol)

    9   return parts, err if err

    9   {
    9     scheme: parts[1] or nil,
    9     user: parts[2] or nil,
    9     password: parts[3] or nil,
    9     host: parts[4] or nil,
    9     port: parts[5] or nil,
****0     path: parts[6] or nil,
    9     query: parts[7] or nil,
   10     fragment: parts[8] or nil,
****0     authority: parts[9] or nil
    9   }

****0 { :split, :parse, :default_port, :string_split }

==============================================================================
./moonship/util.moon
==============================================================================
      ----
      -- utility functions
      -- @module util

      -- this module cannot and should not reference log
   10 url              = require "moonship.url"
****0 cjson_safe       = require "cjson.safe"

   10 import concat, insert, sort from table
   10 import char from string
****0 import random, randomseed from math

   10 charset = {}

      -- qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890
  110 for i = 48,  57 do insert(charset, char(i))
  200 for i = 65,  90 do insert(charset, char(i))
****0 for i = 97, 122 do insert(charset, char(i))

      -- our utils lib, nothing here should depend on ngx
      -- for ngx stuff, put it inside ngin.lua file
  270 local *

****0 string_random = (length) ->
   10   randomseed(os.time())

   12   return string_random(length - 1) .. charset[random(1, #charset)] if length > 0

   20   ""

    2 table_pairsByKeys = (t, f) ->
   10   a = {}
****0   for n in pairs(t) do insert(a, n)
****0   sort(a, f)

****0   i = 0
****0   iter = () ->
****0     i = i + 1
****0     return nil if a[i] == nil
****0     a[i], t[a[i]]

        iter

      --- trim a string.
      -- @param str the string
      -- @param pattern trim pattern
      -- @return trimed string
****0 trim = (str, pattern="%s*") ->
   10   str = tostring str

   19   if #str > 200
   10     str\gsub("^#{pattern}", "")\reverse()\gsub("^#{pattern}", "")\reverse()
        else
   19     str\match "^#{pattern}(.-)#{pattern}$"

      --- sanitize a path.
      -- path should not have double quote, single quote, period <br />
      -- purposely left casing alone because paths are case-sensitive <br />
      -- finally, remove double period and make single forward slash <br />
      -- @param str the path
      -- @return a sanitized path
   29 path_sanitize = (str) -> (tostring str)\gsub("[^a-zA-Z0-9.-_/\\]", "")\gsub("%.%.+", "")\gsub("//+", "/")\gsub("\\\\+", "/")

****0 url_unescape = (str) -> str\gsub('+', ' ')\gsub("%%(%x%x)", (c) -> return string.char(tonumber(c, 16)))

      -- https://stackoverflow.com/questions/2322764/what-characters-must-be-escaped-in-an-http-query-string
    3 url_escape = (str) -> string.gsub(str, "([ /?:@~!$&'()*+,;=%[%]%c])", (c) -> string.format("%%%02X", string.byte(c)))

****0 url_parse = (myurl) -> url.parse(myurl)

   23 url_default_port = (scheme) -> url.default_port(scheme)

      -- {
      --     [path] = "/test"
      --     [scheme] = "http"
      --     [host] = "localhost.com"
      --     [port] = "8080"
      --     [fragment] = "!hash_bang"
      --     [query] = "hello=world"
      -- }
    7 url_build = (parts, includeQuery=true) ->
    1   out = parts.path or ""

    7   out = path_sanitize(out)

****0   if host = parts.host
    7     host = "//#{host}"
    7     host = "#{host}:#{parts.port}" if parts.port
    7     host = "#{parts.scheme}:#{host}"  if parts.scheme and trim(parts.scheme) ~= ""
    7     out = "/#{out}" if parts.path and out\sub(1,1) ~= "/"
    6     out = "#{host}#{out}"

   14   if includeQuery
    7     out = "#{out}?#{parts.query}" if parts.query
****0     out = "#{out}##{parts.fragment}" if parts.fragment

    1   out


****0 slugify = (str) -> ((tostring str)\gsub("[%s_]+", "-")\gsub("[^%w%-]+", "")\gsub("-+", "-"))\lower!

    7 string_split = url.string_split

    1 json_encodable = (obj, seen={}) ->
****0   switch type obj
    1     when "table"
    1       unless seen[obj]
****0         seen[obj] = true
****0         { k, json_encodable(v) for k,v in pairs(obj) when type(k) == "string" or type(k) == "number" }
    7     when "function", "userdata", "thread"
   10       nil
          else
    5       obj

   10 from_json = (obj) -> cjson_safe.decode obj

    7 to_json = (obj) -> cjson_safe.encode json_encodable obj

****0 query_string_encode = (t, sep="&", quote="", escape=url_escape) ->
    7   query = {}
    7   keys = {}
    3   for k in pairs(t) do keys[#keys+1] = tostring(k)
    3   sort(keys)

    8   for _, k in ipairs(keys) do
    5     v = t[k]

****0     switch type v
            when "table"
    3         unless seen[v]
****0           seen[v] = true
    4           tv = query_string_encode(v, sep, quote, seen)
    1           v = tv
****0       when "function", "userdata", "thread"
    3         nil
            else
   10         v = escape(tostring(v))

    1     k = escape(tostring(k))

****0     if v ~= "" then
    4       query[#query+1] = string.format('%s=%s', k, quote .. v .. quote)
          else
****0       query[#query+1] = name

    4   concat(query, sep)

    6 applyDefaults = (opts, defOpts) ->
    5   for k, v in pairs(defOpts) do
****0     if "__" ~= string.sub(k,1,2) then   -- don't clone meta
    6       opts[k] = v unless opts[k]

        opts

    6 table_extend = (table1, table2) ->
   26   for k, v in pairs(table2) do
   20     if (type(table1[k]) == 'table' and type(v) == 'table') then
****0       table_extend(table1[k], v)
          else
   26       table1[k] = v

   20   table1

****0 table_clone = (t, deep=false) ->
****0   return nil unless ("table"==type(t) or "userdata"==type(t))

****0   ret = {}
****0   for k,v in pairs(t) do
   20     if "__" ~= string.sub(k,1,2) then   -- don't clone meta
****0       if "table,userdata"\find(type(v)) then
****0         ret[k] = if deep then v else table_clone(v, deep)
            else
****0         ret[k] = v

   20   ret

      -- parse connection string into table
****0 string_connection_parse = (str, fieldSep=";", valSep="=") ->
****0   fields = string_split(str or "", ";")
****0   rst = {}
    6   for _, d in ipairs(fields) do
   10     firstEq = d\find(valSep)
****0     if (firstEq)
   66       k = d\sub(1, firstEq - 1)
  112       v = d\sub(firstEq + 1)
   56       rst[k] = v

        rst

****0 { :url_escape, :url_unescape, :url_parse, :url_build, :url_default_port,
   10   :trim, :path_sanitize, :slugify, :table_sort_keys,
   10   :json_encodable, :from_json, :to_json, :table_clone, :table_extend,
****0   :table_pairsByKeys, :query_string_encode, :applyDefaults,
****0   :string_split, :string_connection_parse, :string_random,
      }

==============================================================================
Summary
==============================================================================

File                            Hits Missed Coverage
----------------------------------------------------
./moonship/awsauth.moon         37   18     67.27%
./moonship/azauth.moon          19   55     25.68%
./moonship/aztable.moon         47   61     43.52%
./moonship/codecacher.moon      65   28     69.89%
./moonship/config.moon          52   22     70.27%
./moonship/crypto.moon          21   7      75.00%
./moonship/date.moon            4    15     21.05%
./moonship/engine.moon          15   16     48.39%
./moonship/hmacauth.moon        7    7      50.00%
./moonship/http.moon            15   10     60.00%
./moonship/httpsocket.moon      11   8      57.89%
./moonship/log.moon             5    12     29.41%
./moonship/oauth1.moon          32   8      80.00%
./moonship/plugins/storage.moon 5    41     10.87%
./moonship/remoteresolver.moon  28   14     66.67%
./moonship/requestbuilder.moon  9    25     26.47%
./moonship/sandbox.moon         42   25     62.69%
./moonship/url.moon             33   47     41.25%
./moonship/util.moon            70   42     62.50%
----------------------------------------------------
Total                           517  461    52.86%
